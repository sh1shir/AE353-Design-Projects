import numpy as np
class Controller():
    def __init__(self):
        self.A = np.array([[ 0.  ,  0.  ,  0.  ,  1.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,
         0.  ,  0.  ,  0.  ],
       [ 0.  ,  0.  ,  0.  ,  0.  ,  1.  ,  0.  ,  0.  ,  0.  ,  0.  ,
         0.  ,  0.  ,  0.  ],
       [ 0.  ,  0.  ,  0.  , -0.  ,  0.  ,  1.  ,  0.  ,  0.  ,  0.  ,
         0.  ,  0.  ,  0.  ],
       [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  , -0.  ,  0.  ,  9.81,  0.  ,
         0.  , -0.  ,  0.  ],
       [ 0.  ,  0.  ,  0.  , -0.  ,  0.  ,  0.  , -9.81,  0.  ,  0.  ,
         0.  ,  0.  , -0.  ],
       [ 0.  ,  0.  ,  0.  ,  0.  , -0.  ,  0.  ,  0.  ,  0.  ,  0.  ,
        -0.  ,  0.  ,  0.  ],
       [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,
         1.  ,  0.  ,  0.  ],
       [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,
         0.  ,  1.  , -0.  ],
       [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,
         0.  ,  0.  ,  1.  ],
       [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,
         0.  , -0.  , -0.  ],
       [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,
         0.  ,  0.  ,  0.  ],
       [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ,
         0.  ,  0.  ,  0.  ]])
        
        self.B = np.array([[  0.       ,   0.       ,   0.       ,   0.       ],
       [  0.       ,   0.       ,   0.       ,   0.       ],
       [  0.       ,   0.       ,   0.       ,   0.       ],
       [  0.       ,   0.       ,   0.       ,   0.       ],
       [  0.       ,   0.       ,   0.       ,   0.       ],
       [  0.       ,   0.       ,   0.       ,   2.       ],
       [  0.       ,   0.       ,   0.       ,   0.       ],
       [  0.       ,   0.       ,   0.       ,   0.       ],
       [  0.       ,   0.       ,   0.       ,   0.       ],
       [434.7826087,   0.       ,   0.       ,   0.       ],
       [  0.       , 434.7826087,   0.       ,   0.       ],
       [  0.       ,   0.       , 250.       ,   0.       ]])
        
        self.C = np.array([[ 1.      ,  0.      ,  0.      ,  0.      ,  0.      ,  0.      ,
         0.      ,  0.046875,  0.      ,  0.      ,  0.      ,  0.      ],
       [ 0.      ,  1.      ,  0.      ,  0.      ,  0.      ,  0.      ,
        -0.046875,  0.      ,  0.25    ,  0.      ,  0.      ,  0.      ],
       [ 0.      ,  0.      ,  1.      ,  0.      ,  0.      ,  0.      ,
        -0.      , -0.25    ,  0.      ,  0.      ,  0.      ,  0.      ],
       [ 1.      ,  0.      ,  0.      ,  0.      ,  0.      ,  0.      ,
         0.      ,  0.046875, -0.25    ,  0.      ,  0.      ,  0.      ],
       [ 0.      ,  1.      ,  0.      ,  0.      ,  0.      ,  0.      ,
        -0.046875,  0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
       [ 0.      ,  0.      ,  1.      ,  0.      ,  0.      ,  0.      ,
         0.25    , -0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
       [ 1.      ,  0.      ,  0.      ,  0.      ,  0.      ,  0.      ,
         0.      ,  0.046875,  0.      ,  0.      ,  0.      ,  0.      ],
       [ 0.      ,  1.      ,  0.      ,  0.      ,  0.      ,  0.      ,
        -0.046875,  0.      , -0.25    ,  0.      ,  0.      ,  0.      ],
       [ 0.      ,  0.      ,  1.      ,  0.      ,  0.      ,  0.      ,
        -0.      ,  0.25    ,  0.      ,  0.      ,  0.      ,  0.      ],
       [ 1.      ,  0.      ,  0.      ,  0.      ,  0.      ,  0.      ,
         0.      ,  0.046875,  0.25    ,  0.      ,  0.      ,  0.      ],
       [ 0.      ,  1.      ,  0.      ,  0.      ,  0.      ,  0.      ,
        -0.046875,  0.      ,  0.      ,  0.      ,  0.      ,  0.      ],
       [ 0.      ,  0.      ,  1.      ,  0.      ,  0.      ,  0.      ,
        -0.25    ,  0.      ,  0.      ,  0.      ,  0.      ,  0.      ]])

        self.K = np.array([[-2.12939371e-18, -3.75000000e-03, -4.44199060e-19,
        -1.00271299e-18, -6.69858352e-03, -1.71735588e-17,
         4.69192957e-02,  5.06668781e-18,  8.76307517e-17,
         1.49942909e-02,  1.54557754e-18,  4.49079056e-17],
       [ 3.75000000e-03,  1.07867180e-18, -6.79239038e-20,
         6.69858352e-03, -8.97232765e-19, -1.78819105e-19,
         4.52944479e-19,  4.69192957e-02, -1.65199630e-17,
         1.54557754e-18,  1.49942909e-02, -6.10400992e-18],
       [-3.25976155e-18,  3.95593005e-18, -1.98822971e-17,
        -6.09524122e-18,  4.62506187e-18, -6.16057868e-18,
         1.17447189e-17, -3.13994617e-17,  2.00000000e-02,
         2.58220457e-17, -3.50980570e-18,  1.30000000e-02],
       [-2.30374306e-16,  1.17513424e-14,  1.87500000e+00,
        -2.53098353e-16,  1.39942473e-14,  2.03100960e+00,
        -8.00614908e-14, -8.57068826e-16, -1.27374281e-14,
        -1.97495926e-14, -2.05641970e-16, -1.23211574e-14]])
        
        self.L = np.array([[ 1.60290621e+00,  3.42419815e-16, -1.90234589e-01,
         1.60290621e+00,  3.35198706e-16, -6.18544002e-17,
         1.60290621e+00,  3.27977597e-16,  1.90234589e-01,
         1.60290621e+00,  3.35198706e-16,  1.22086124e-16],
       [ 3.45240399e-16,  1.60290621e+00, -2.33966253e-16,
         2.10888120e-16,  1.60290621e+00, -1.90234589e-01,
         3.45240399e-16,  1.60290621e+00,  5.70856598e-17,
         4.79592677e-16,  1.60290621e+00,  1.90234589e-01],
       [ 2.98540353e-17, -2.18462789e-16,  7.07106781e-01,
         1.62655494e-16, -8.56613297e-17,  7.07106781e-01,
         2.98540353e-17,  4.71401295e-17,  7.07106781e-01,
        -1.02947424e-16, -8.56613297e-17,  7.07106781e-01],
       [ 4.91038697e+00,  2.85045744e-15, -1.25643282e+00,
         4.91038697e+00,  2.64557909e-15, -6.66069861e-16,
         4.91038697e+00,  2.44070075e-15,  1.25643282e+00,
         4.91038697e+00,  2.64557909e-15,  7.63973313e-16],
       [ 1.97097322e-15,  4.91038697e+00, -1.17785918e-15,
         1.75802014e-15,  4.91038697e+00, -1.25643282e+00,
         1.97097322e-15,  4.91038697e+00,  1.97842283e-16,
         2.18392631e-15,  4.91038697e+00,  1.25643282e+00],
       [-3.53763550e-17, -5.04661103e-16,  5.00000000e-01,
         2.39287709e-16, -2.29997038e-16,  5.00000000e-01,
        -3.53763550e-17,  4.46670260e-17,  5.00000000e-01,
        -3.10040419e-16, -2.29997038e-16,  5.00000000e-01],
       [-4.02434001e-16, -8.28190464e-01,  1.24997782e-16,
        -2.33044797e-16, -8.28190464e-01,  3.58677917e-01,
        -4.02434001e-16, -8.28190464e-01, -2.43567048e-16,
        -5.71823205e-16, -8.28190464e-01, -3.58677917e-01],
       [ 8.28190464e-01,  6.33217836e-16, -3.58677917e-01,
         8.28190464e-01,  6.16656779e-16, -1.89868049e-16,
         8.28190464e-01,  6.00095722e-16,  3.58677917e-01,
         8.28190464e-01,  6.16656779e-16,  1.78696781e-16],
       [ 3.19896354e-17,  1.11803399e+00, -5.47766894e-16,
        -1.11803399e+00,  5.69169589e-16, -7.00595040e-16,
         3.19896354e-17, -1.11803399e+00, -5.14644779e-16,
         1.11803399e+00,  5.69169589e-16, -3.61816633e-16],
       [-2.14106835e-16, -4.67677183e-01,  1.83017919e-16,
        -4.56082860e-17, -4.67677183e-01,  2.50112184e-01,
        -2.14106835e-16, -4.67677183e-01,  1.87057976e-17,
        -3.82605383e-16, -4.67677183e-01, -2.50112184e-01],
       [ 4.67677183e-01, -2.15949899e-16, -2.50112184e-01,
         4.67677183e-01, -2.10384101e-16,  1.40125547e-16,
         4.67677183e-01, -2.04818303e-16,  2.50112184e-01,
         4.67677183e-01, -2.10384101e-16,  8.16508297e-17],
       [ 6.45981149e-17,  5.00000000e-01, -5.64458302e-16,
        -5.00000000e-01,  8.13989592e-17, -5.89831597e-16,
         6.45981149e-17, -5.00000000e-01, -5.24683984e-16,
         5.00000000e-01,  8.13989592e-17, -4.99310689e-16]])

        
        self.m_e = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
        self.n_e = np.array([0, 0, 0, 9.81 / 2])
        self.q_e = np.array([ 0.25    ,  0.      ,  0.046875,  0.      ,  0.25    ,  0.046875,
       -0.25    ,  0.      ,  0.046875,  0.      , -0.25    ,  0.046875])

        self.e_max = 0.5
        pass

    
    def reset(self):
        self.xhat = np.zeros(12,)
        # self.m = np.zeros(12,)
        self.n = np.zeros(4,)
        self.last_p_goal = np.zeros(3)
        self.gate_count = 0
        pass
    
    
    def run(self, **kwargs):
        self.dt = kwargs["dt"]
        self.p_goal = kwargs["next_gate"]
        self.p_goal_direction = kwargs["dir_gate"]
        p_hat = self.xhat[:3]
        
        # implement gradient descent for collision avoidance
        k_attract = 20.
        k_repel = 0.
        k_des = 0.5
        r_drone = 0.5
        s = r_drone
        
        p_goal = kwargs['next_gate']
        if (self.last_p_goal[0] == 0 and self.last_p_goal[1] == 0 and self.last_p_goal[2] == 0):
            self.last_p_goal = kwargs['next_gate']
            self.gate_count += 1
        elif (self.last_p_goal[0] != p_goal[0] or self.last_p_goal[1] != p_goal[1] or self.last_p_goal[2] != p_goal[2]):
            self.last_p_goal = kwargs['next_gate']
            self.gate_count += 1

            
        # calculate the attractive Part
        if (self.gate_count > 4):
            k_des = 1
            k_attract = 8.
        if (self.gate_count == 6):
            k_attract = 20.
            if (np.linalg.norm(p_hat - self.p_goal) < 25):
                k_attract = 7.
    
        if kwargs["is_last_gate"] == True:
            k_attract = 40.
        
        h_attract = k_attract*((p_hat - self.p_goal) / np.linalg.norm(p_hat - self.p_goal))

        
        # Calculate the Repulsive Part
        h_repel = np.array([0.0,0.0,0.0])
        for q in kwargs["pos_others"]:
            #Repulsion of Other Drones
            p_obst = q + s*((p_hat - q)/np.linalg.norm(p_hat - q))
            grad_d = (p_hat - p_obst)/np.linalg.norm((p_hat - p_obst))
            d_p = np.linalg.norm((p_hat - p_obst))
            k_repel = 6.
            h_repel += -k_repel*((grad_d/(d_p*d_p)))[0]
           
            #If the drone is too close to the floor, get away
            if p_hat[2] < 1.0:
                k_repel = 1.
                h_repel += -k_repel * np.array([0.0,0.0,5.0])

        if (self.gate_count > 1):
            h_repel = np.zeros(3)
            
        # Combining the terms
        h = h_attract + h_repel

        # minimize error using gradient descent method
        if np.linalg.norm(self.p_goal - p_hat) < self.e_max:
            self.p_des = self.p_goal
        else:
            self.p_des = p_hat - k_des*h

        #Calculate x desired
        self.x_des = np.block([self.p_des, np.zeros(9)])

        #Find inputs using tracking and linear feedback
        u = -self.K@(self.xhat - self.x_des)
        inputs = u + self.n_e

        #Update x estimation
        o = np.block([kwargs["mocap_1"], kwargs["mocap_2"], kwargs["mocap_3"], kwargs["mocap_4"]])
        y = o - self.q_e
        self.xhat += self.dt * (self.A@self.xhat + self.B@u - self.L@(self.C@self.xhat - y))

        return inputs
    
    
    
###############################################################################
#CREATE THE MAKE_CONTROLLER() FUNCTION
###############################################################################
"""
VALID TEAM NAMES:
    the ORB
    Team Kachow
    Team Steam Tunnels
    Team Flying Mambas
    Team Spare Chang-e
    the Flying Illini
"""
def make_controller():
    controller_instance = Controller()
    team_name = "Team Kachow"
    return (controller_instance, team_name)